## ES的Term查询

### 1. Term注意点

ES在做Term查询时,不会对查询的词做分词处理，但是，再添加时会默认做一次分词处理

```json
#Term 查询
POST /products/_bulk
{ "index": { "_id": 1 }}
{ "ProductID" : "XHDK-A-1293-#fJ3","desc": "iPhone" }
{ "index": { "_id": 2 }}
{ "ProductID" : "KDKE-B-9947-#kL5","desc": "iPad" }
{ "index": { "_id": 3 }}
{ "ProductID" : "JODL-X-1937-#pV7","desc": "MBP" }

GET /products

POST /products/_search
{
  "query":{
    "term": {
      "desc":{
        "value":"iPhone"	//查询不出数据
        //"value":"iphone"	//可以查询出数据
      }
    }
  }
}


POST /products/_search
{
  "query":{
    "term":{
      "ProductID": {
        //"value": "XHDK-A-1293-#fJ3"
       "value": "xhdk-a-1293-#fj3"
      }
    }
  }
}

POST /_analyze
{
  "analyzer": "standard",
  "text": ["XHDK-A-1293-#fJ3"]
}

```

### 2.多字段Mapping

```json
GET /products/_mapping
{
  "products" : {
    "mappings" : {
      "properties" : {
        "ProductID" : {
          "type" : "text",
          "fields" : {
            "keyword" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        },
        "desc" : {
          "type" : "text",
          "fields" : {
            "keyword" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        }
      }
    }
  }
}
```

### 3.复合查询

- 将Query转成Filter，忽略TF-IDF计算，避免相关性算分的开销
- Filter可以有效利用缓存

```json

```



### 4.基于全文查询

- 基于全文本的查找
  - Match Query / Match Phrase Query / Query String Query
- 特点
  - 索引和搜索时都会进行分词，查询字符串先传递到一个合适的分词器，然后生成一个供查询的词项列表
  - 查询时候，先对输入的查询进行分词，然后每个词项逐个进行底层查询，最终将结果进行合并。并为每个文档生成一个算分。例如查“Matrix reloaded”，会查到包含Matrix和reload的所有结果



## 结构化搜索

- 结果化搜索是指对结构化数据的搜索
  - 日期，布尔类型和数字都是结构化搜索
- 文本也可以是结构化的
  - 如彩色笔可以有离散的颜色集合：红（red）、绿（green）、蓝（blue）
  - 一个博客可以被标记标签，例如：分布式和搜索
  - 电商网站上的商品都有UPCS（通用产品码）或其他的唯一标识，他们都需要遵从严格规定的、结构化的格式
- 布尔，时间、日期、数字这类结构化数据：有精确的格式，我们可以对这些格式进行逻辑操作。包括比较数字或时间的范围，或判定两个值的大小
- 结构化的文本可以做精确的匹配或部分匹配
  - Term查询/Prefix前缀查询
- 结构化结果只有“是”或“否”两个值
  - 根据场景需要，可以决定结构化搜索是否需要打分

```json
//结构化搜索，精确匹配
DELETE products
POST /products/_bulk
{ "index": { "_id": 1 }}
{ "price" : 10,"available": true,"date":"2018-01-01","productID": "XHDK-A-1293-#fJ3" }
{ "index": { "_id": 2 }}
{ "price" : 20,"available": true,"date":"2019-01-01","productID": "KDKE-B-9947-#kL5" }
{ "index": { "_id": 3 }}
{ "price" : 30,"available": true,"productID": "JODL-X-1937-#pV7" }
{ "index": { "_id": 4 }}
{ "price" : 30,"available": false,"productID": "QQPX-R-3956-#aD8" }

GET products/_mapping

//对布尔值match查询，有算分
POST products/_search
{
    "profile":"true",
    "explain":true,
    "query":{
        "term":{
            "available": true
        }
    }
}

//对布尔值，通过constant score转成filtering，没有算分
POST products/_search
{
    "profile":"true",
    "explain":true,
    "query":{
        "constant_score":{
            "filter":{
                "term":{
                    "available": true
                }
            }
        }
    }
}

//数字类型

//数字Range查询
GET products/_search
{
    "query":{
        "constant_score":{
            "filter":{
                "range":{
                    "price": {
                        "gte":20,
                        "lte":30
                    }
                }
            }
        }
    }
}

//日期 range
POST products/_search
{
    "query":{
        "constant_score":{
            "filter":{
                "range":{
                    "date": {
                        "gte":"now-3y"
                    }
                }
            }
        }
    }
}

//Exists
POST products/_search
{
    "query":{
        "constant_score":{
            "filter":{
                "exists":{
                    "field":"date"
                }
            }
        }
    }
}

//处理多值字段
POST /movies/_bulk
{ "index": { "_id": 1 }}
{ "title" : "Father of the Bridge Part II","year": 1995,"gener":"Comedy" }
{ "index": { "_id": 2 }}
{ "title" : "Dave","year": 1993,"gener":["Comedy","Romance"] }

//处理多值字段，term查询是包含，而不是等于
POST movies/_search
{
    "query":{
        "constant_score":{
            "filter":{
                "term":{
                    "gener.keyword":"Comedy"
                }
            }
        }
    }
}
```

## 相关性和相关性算分



- 相关性 -- Relevance
  - 搜索的相关性算分，描述了一个文档和查询语句匹配的程度。ES会对每个匹配查询条件的结果进行算分_score
  - 打分的本质是排序，需要把最符合用户需求的文档排在前面。ES5之前，默认的相关性算分采用TF-IDF，现在采用BM25

**词频TF**

- Term Frequency：检索词在一篇文档中出现的频率
  - 检索词出现的次数除以文档的总字数
- 度量一个查询和结果文档相关性的简单方法：简单将搜索中每一个词的TF进行相加
  - TF（区块链）+TF（的）+ TF（应用）
- Stop Word
  - ”的“在文档中出现很多次，但是对贡献相关度几乎没有用处，不应该考虑他们的TF

**逆文档频率IDF**

- DF：检索词在所有文档中出现的频率
  - ”区块链“在相对比较少的文档中出现
  - ”应用“在相对比较多的文档中出现
  - “Stop Word”在大量文档中出现
- Inverse Document Frequency：简单说=log（全部文档数/检索词出现过的文档总数）
- TF-IDF本质上就是将TF求和变成了加权求和
  - TF(区块链)*IDF（区块链）+ TF(的) *IDF（的）+ TF(应用) * IDF（应用）

```json
PUT testscore/_bulk
{ "index": { "_id": 1 }}
{ "content": "we use Elasticsearch to power the search" }
{ "index": { "_id": 2 }}
{ "content": "we like elasticsearch" }
{ "index": { "_id": 3 }}
{ "content": "The scoring of documents is caculated by the scoring formula" }
{ "index": { "_id": 4 }}
{ "content": "you know, for search" }

POST /testscore/_search
{
    // "explain":false,
    "query":{
        "match":{
            // "content":"you"
            "content":"elasticsearch"
            // "content":"the"
            // "content":"the elasticsearch"
        }
    }
}
```

**Boosting Relevance**

- Boosting是控制相关度的一种手段
  - 索引、字段或者查询子条件
- 参数boost的含义
  - 当boost>1时，打分的相关度相对性提升
  - 当0< boost < 1时，打分的权重相对性降低
  - 当boost < 0时，贡献负分

```json
POST /testscore/_search
{
    // "explain":false,
    "query":{
        "boosting":{
           "positive":{
                "term":{
                 	"content":"elasticsearch"   
                }
            },
            "negative":{
                "term":{
                 	"content":"like"   
                }
            },
            "negative_boost":0.2
        }
    }
}
```

## Query&Filtering与多字符串多字段查询

- 高级搜索的功能：支持多项文本输入，针对多个字段进行搜索
- 搜索引擎一般也提供基于时间、价格等条件的过滤
- 在Elasticsearch中，有Query和Filter两种不同Context
  - Query Context：相关性算分
  - Filter Context：不需要算分（Yes or No），可以利用Cache，获得更好的性能

**条件组合**

- 假设要搜索一本电影，包含了一下一些条件
  - 评论中包含Guitar，用户打分高于3分，同时上映日期要在1993与2000年之间
- 这个搜索其实包含3段逻辑，针对不同的字段
  - 评论字段中要包含Guitar / 用户评分大于3 / 上映日期日期需要在给定的范围
- 同时包含三个逻辑，并且有比较好的性能？
  - 复合查询： bool Query

**bool查询**

- 一个bool查询，是一个或者多个查询子句的组合

  - 总共包含4种子句，其中2种会影响算分，2种不影响算分

- 相关性并不只是全文本检索的专利。也适用于yes|no的子句，匹配的子句越多，相关性评分越高。如果多条查询子句被合并为一条复合查询语句，比如bool查询，则每个查询子句计算得出的评分会被合并到总的相关性评分中。

  | must     | 必须匹配，贡献算分                      |
  | -------- | :-------------------------------------- |
  | should   | 选择行匹配，贡献算分                    |
  | must_not | Filter Context 查询子句，必须不能匹配   |
  | filter   | Filter Context 必须匹配，但是不贡献算分 |

**bool查询语法**

- 子查询可以任意顺序出现
- 可以嵌套多个查询
- 如果你的bool查询中，没有must条件，should中必须至少满足一条查询

```json
POST /products/_search
{
    "query":{
        "bool":{
           "must":{
                "term":{
                 	"price":30   
                }
            },
            "filter":{
                "term":{
                 	"avaliable":true   
                }
            },
            "must_not":{
                "range":{
                 	"price":{ "lte": 10 }  
                }
            },
            "should":[
              { "term":{ "productID.keyword":"JODL-X-1937-#pV7"   }},
              { "term":{ "productID.keyword":"XHDK-A-1293-#fJ3"   }}
            ],
            "minimum_should_match":1
        }
    }
}
```

**如何解决结构化查询-“包含而不是相等”的问题**

```json
//处理多值字段，term查询是包含，而不是等于
POST movies/_search
{
    "query":{
        "constant_score":{
            "filter":{
                "term":{
                    "gener.keyword":"Comedy"
                }
            }
        }
    }
}

{
  "took" : 0,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 2,
      "relation" : "eq"
    },
    "max_score" : 1.0,
    "hits" : [
      {
        "_index" : "movies",
        "_type" : "_doc",
        "_id" : "1",
        "_score" : 1.0,
        "_source" : {
          "title" : "Father of the Bridge Part II",
          "year" : 1995,
          "gener" : "Comedy"
        }
      },
      {
        "_index" : "movies",
        "_type" : "_doc",
        "_id" : "2",
        "_score" : 1.0,
        "_source" : {
          "title" : "Dave",
          "year" : 1993,
          "gener" : [
            "Comedy",
            "Romance"
          ]
        }
      }
    ]
  }
}
```

解决方案：增加一个gener_count字段进行

- 从业务角度，按需改进Elasticsearch数据模型

```json
POST /newmovies/_bulk
{ "index": { "_id": 1 }}
{ "title" : "Father of the Bridge Part II","year": 1995,"gener":"Comedy","gener_count":1 }
{ "index": { "_id": 2 }}
{ "title" : "Dave","year": 1993,"gener":["Comedy","Romance"],"gener_count":2 }

//影响算分
POST newmovies/_search
{
    "query":{
        "bool":{
            "must":[
             	{
                    "term":{
                        "gener.keyword":{ "value":"Comedy"}
                    }
                },
                {
                    "term":{
                        "gener_count":{ "value":1}
                    }
                } 
            ]
        }
    }
}

//不影响算分
POST newmovies/_search
{
    "query":{
        "bool":{
            "filter":[
             	{
                    "term":{
                        "gener.keyword":{ "value":"Comedy"}
                    }
                },
                {
                    "term":{
                        "gener_count":{ "value":1}
                    }
                } 
            ]
        }
    }
}
```

**查询语句的结构，会对相关度算分产生影响**

```json
POST /animals/_search
{
    "query":{
        "bool":{
            "should":[
             	{ "term":{ "text":"brown" }},
                { "term":{ "text":"red" }},
                { "term":{ "text":"quick" }},
                { "term":{ "text":"dog" }}
            ]
        }
    }
}

POST /animals/_search
{
    "query":{
        "bool":{
            "should":[
             	{ "term":{ "text":"brown" }},
                { "term":{ "text":"red" }},
                { "bool":{
                    "should":[
                        { "term":{ "text":"quick" }},
                		{ "term":{ "text":"dog" }}
                    ]
                }}
            ]
        }
    }
}
```

- 同一层级下的竞争字段，具有相同的权重
- 通过嵌套bool查询，可以改变对算分的影响

**控制字段Boost**

```json
DELETE blogs
POST /blogs/_bulk
{ "index": { "_id": 1 }}
{ "title" : "Apple iPad","content":"Apple iPad,Apple iPad" }
{ "index": { "_id": 2 }}
{ "title" : "Apple iPad,Apple iPad","content":"Apple iPad" }

POST /blogs/_search
{
    "query":{
        "bool":{
            "should":[
                {
                    "match":{ 
                        "title":{ 
                            "query":"apple,ipad",
                            "boost":1.1
                        }
                    }
                    
                },
                {
                    "match":{ 
                        "content":{ 
                            "query":"apple,ipad",
                            "boost":1
                        }
                    }
                    
                }
            ]
        }
    }
}
```

Not Quite Not

- 要求苹果公司的产品信息优先

```json
POST /news/_bulk
{ "index": { "_id": 1 }}
{ "content":"Apple Mac" }
{ "index": { "_id": 2 }}
{ "content":"Apple iPad" }
{ "index": { "_id": 3 }}
{ "content":"Apple employee like Apple Pie and Apple Juice" }

POST /news/_search
{
    "query":{
        "bool":{
           "must":{ 
               "match":{ 
                   "content":"apple"
               }
           }
        }
    }
}

//排除了包含pie
POST /news/_search
{
    "query":{
        "bool":{
           "must":{ 
               "match":{ 
                   "content":"apple"
               }
           },
            "must_not":{ 
               "match":{ 
                   "content":"pie"
               }
           }
        }
    }
}

POST /news/_search
{
    "query":{
        "boosting":{
           "positive":{ 
               "match":{ 
                   "content":"apple"
               }
           },
            "negative":{ 
               "match":{ 
                   "content":"pie"
               }
           },
            "negative_boost":0.5
        }
    }
}
```



