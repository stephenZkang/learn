## HTTP协议

### HTTP1.1 默认支持长链接详解

​		相传http1.0不支持长链接，http1.1连接默认支持长链接，其实，这种传言是一种误解，http协议本身无长链接、短连接之说。

​		官解：**HTTP协议是基于请求/响应模式的，因此只要服务端给了响应，本次HTTP连接就结束了**

​		而说http分为长连接和短连接，其实，http处于OSI七层协议的第七层应用层，再往下的第四层是TCP协议，这里的长连接和短连接实际说的是TCP协议。

​		官解: **TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才有真正的长连接和短连接这一说**

​		

### 疑问

​		http如何设置长连接，是不是设置connection为keep-alive就可以了？

​		如果是的话，那都说HTTP1.1默认是长连接，而观察我们平时开发的Web应用的HTTP头部，Connection也确实是keep-alive，那就是说我们大部分都是用的长连接，但是长连接不是一般用于交互比较频繁的应用吗？像我们这种普通的Web应用，比如博客园这种，或者我的个人博客这种，长连接有什么用？

​		第一个问题是，是不是只要设置Connection为keep-alive就算是长连接了？

​			当然是的，但要服务器和客户端都设置。

​		第二个问题是，我们平时用的是不是长连接？

​			这个也毫无疑问，当然是的。（现在用的基本上都是HTTP1.1协议，你观察一下就会发现，基本上Connection都是keep-alive。而且HTTP协议文档上也提到了，HTTP1.1默认是长连接，也就是默认Connection的值就是keep-alive）

​		第三个问题，也是LZ之前最想不明白的问题，那就是我们这种普通的Web应用（比如博客园，我的个人博客这种）用长连接有啥好处？需不需要关掉长连接而使用短连接？

​		这个问题LZ现在终于明白了，问题的答案是好处还是有的。

​		首先，刚才已经说了，长连接是为了复用，这个在之前LZ就明白。那既然长连接是指的TCP连接，也就是说复用的是TCP连接。那这就很好解释了，也就是说，长连接情况下，多个HTTP请求可以复用同一个TCP连接，这就节省了很多TCP连接建立和断开的消耗。

​		另外，最后关于长连接还要多提一句，那就是，长连接并不是永久连接的。如果一段时间内（具体的时间长短，是可以在header当中进行设置的，也就是所谓的超时时间），这个连接没有HTTP请求发出的话，那么这个长连接就会被断掉。

​		这一点其实很容易理解，否则的话，TCP连接将会越来越多，直到把服务器的TCP连接数量撑爆到上限为止。现在想想，对于服务器来说，服务器里的这些个长连接其实很有数据库连接池的味道，大家都是为了节省连接重复利用嘛，对不对？



### 长轮询和短轮询

​		短轮询相信大家都不难理解，比如你现在要做一个电商中商品详情的页面，这个详情界面中有一个字段是库存量（相信这个大家都不陌生，随便打开淘宝或者京东都能找到这种页面）。而这个库存量需要实时的变化，保持和服务器里实际的库存一致。

​		这个时候，你会怎么做？

​		最简单的一种方式，就是你用JS写个死循环，不停的去请求服务器中的库存量是多少，然后刷新到这个页面当中，这其实就是所谓的短轮询。

​		这种方式有明显的坏处，那就是你很浪费服务器和客户端的资源。客户端还好点，现在PC机配置高了，你不停的请求还不至于把用户的电脑整死，但是服务器就很蛋疼了。如果有1000个人停留在某个商品详情页面，那就是说会有1000个客户端不停的去请求服务器获取库存量，这显然是不合理的。

​		那怎么办呢？

​		长轮询这个时候就出现了，其实长轮询和短轮询最大的区别是，短轮询去服务端查询的时候，不管库存量有没有变化，服务器就立即返回结果了。而长轮询则不是，在长轮询中，服务器如果检测到库存量没有变化的话，将会把当前请求挂起一段时间（这个时间也叫作超时时间，一般是几十秒）。在这个时间里，服务器会去检测库存量有没有变化，检测到变化就立即返回，否则就一直等到超时为止。

​		而对于客户端来说，不管是长轮询还是短轮询，客户端的动作都是一样的，就是不停的去请求，不同的是服务端，短轮询情况下服务端每次请求不管有没有变化都会立即返回结果，而长轮询情况下，如果有变化才会立即返回结果，而没有变化的话，则不会再立即给客户端返回结果，直到超时为止。　

​		这样一来，客户端的请求次数将会大量减少（这也就意味着节省了网络流量，毕竟每次发请求，都会占用客户端的上传流量和服务端的下载流量），而且也解决了服务端一直疲于接受请求的窘境。

​		但是长轮询也是有坏处的，因为把请求挂起同样会导致资源的浪费，假设还是1000个人停留在某个商品详情页面，那就很有可能服务器这边挂着1000个线程，在不停检测库存量，这依然是有问题的。

​		因此，从这里可以看出，不管是长轮询还是短轮询，都不太适用于客户端数量太多的情况，因为每个服务器所能承载的TCP连接数是有上限的，这种轮询很容易把连接数顶满。之所以举这个例子，只是因为大家肯定都会网购，所以这个例子比较通俗一点。

​		哪怕轮询解决不了获取库存这个问题，但只要大家明白了长短轮询的区别，这就足够了。实际上，据LZ自己平日里购物的观察，那个库存量应该是不会变的-_-。、

### 长轮询和长短连接的区别

​		第一个区别是决定的方式，一个TCP连接是否为长连接，是通过设置HTTP的Connection Header来决定的，而且是需要两边都设置才有效。而一种轮询方式是否为长轮询，是根据服务端的处理方式来决定的，与客户端没有关系。

​		第二个区别就是实现的方式，连接的长短是通过协议来规定和实现的。而轮询的长短，是服务器通过编程的方式手动挂起请求来实现的。

### OSI模型

​		OSI模型有7层结构，每层都可以有几个子层。 OSI的7层从上到下分别是 7 [应用层](https://baike.baidu.com/item/应用层/4329788) 6 [表示层](https://baike.baidu.com/item/表示层/4329716) 5 会话层 4 [传输层](https://baike.baidu.com/item/传输层/4329536) 3 网络层 2 [数据链路层](https://baike.baidu.com/item/数据链路层/4329290) 1 [物理层](https://baike.baidu.com/item/物理层/4329158) ；其中高层（即7、6、5、4层）定义了应用程序的功能，下面3层（即3、2、1层）主要面向通过网络的端到端，点到点的[数据流](https://baike.baidu.com/item/数据流/3002243)。

![image-20200508090002540](https://raw.githubusercontent.com/stephenZkang/learn/master/img/image-20200508090002540.png)

​		**应用层**

​			示例：[TELNET](https://baike.baidu.com/item/TELNET/810597)，[HTTP](https://baike.baidu.com/item/HTTP/243074)，[FTP](https://baike.baidu.com/item/FTP/13839)，[NFS](https://baike.baidu.com/item/NFS/812203)，[SMTP](https://baike.baidu.com/item/SMTP/175887)等。

​		**表示层**

​			这一层的主要功能是定义数据格式及加密。例如，FTP允许你选择以二进制或ASCII格式传输。

​		**会话层**

​			它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的		一部分时可以通知应用，从而使表示层看到的数据是连续的，在某些情况下，如果表示层收到了所有的[数		据](https://baike.baidu.com/item/数据/5947370)，则用数据代表表示层。示例：RPC，SQL等。

​		**传输层**

​			这层的功能包括是否选择差错恢复协议还是无差错恢复协议，及在同一[主机](https://baike.baidu.com/item/主机)上对不同应用的[数据流](https://baike.baidu.com/item/数据流)的输入		进行复用，还包括对收到的顺序不对的[数据包](https://baike.baidu.com/item/数据包)的重新排序功能。示例：[TCP](https://baike.baidu.com/item/TCP/33012)，[UDP](https://baike.baidu.com/item/UDP/571511)，[SPX](https://baike.baidu.com/item/SPX/610336)。

​		**网络层**

​			这层对端到端的包传输进行定义，它定义了能够标识所有结点的[逻辑地址](https://baike.baidu.com/item/逻辑地址)，还定义了[路由](https://baike.baidu.com/item/路由)实现的方式和学		习的方式。为了适应[最大传输单元](https://baike.baidu.com/item/最大传输单元)长度小于包长度的[传输介质](https://baike.baidu.com/item/传输介质)，网络层还定义了如何将一个包分解成更小的		包的分段方法。示例：IP，IPX等。

​		**数据链路层**

​			它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：[ATM](https://baike.baidu.com/item/ATM/8314845)，[FDDI](https://baike.baidu.com/item/FDDI/572177)等。

​		**物理层**

​			OSI的物理层规范是有关[传输介质](https://baike.baidu.com/item/传输介质)的特性，这些规范通常也参考了其他组织制定的标准。连接头、帧、帧的		使用、电流、编码及光调制等都属于各种物理层规范中的内容。物理层常用多个规范完成对所有细节的定		义。示例：[Rj45](https://baike.baidu.com/item/Rj45/3401007)，[802.3](https://baike.baidu.com/item/802.3/960717)等。