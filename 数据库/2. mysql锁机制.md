## 数据库乐观锁、悲观锁

### 并发问题 

当程序中出现并发的问题时，我们就要有相应的手段保证数据的正确性，防止多个用户在操作数据的时候，出现和预期数据不一样的现象，产生脏数据，在数据库的层面如果没有做好并发控制，就可能导致脏读、幻读和不可重复读等问题，所以对于并发场景锁机制的应用是非常有效的，保证了数据的准确性。

![image-20200515092440563](https://raw.githubusercontent.com/stephenZkang/learn/master/img/image-20200515092440563.png)


以上的图就表示了并发场景时，在没有锁机制的情况下，产生不正确的数据，与预期的数据并不符合。实现并发控制的主要手段大致可以悲观锁和乐观锁。无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。

### 悲观锁

当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）。

这样别的线程读取该数据的时候就需要等待当前线程释放锁，获得到锁的线程才能获得该数据的读写权限。从而保证了并发修改数据错误的问题。但是由于阻塞原因，所以导致**吞吐量不高。悲观锁更适用于多写少读的情况。**
当某一天，你的好友A说要给你转账1000块，好友B又说给你转账1000块。啥？天上掉馅饼了吗？他们进行了下面的操作：



1. 好友A和好友B同时来到银行，首先好友A获取到你的余额为0，太穷了。
2. 好友B此时获取不到你的余额，因此好友B处于阻塞状态，等待ing…….。
3. 好友A给你的银行账号里面汇入1000块，总额等于money=money+1000。
4. 好友A操作完，此时好友B获取到你的余额1000块，然后执行转账操作money=money+1000，最后你的余额为2000。

假设转账的过程没有锁机制

1. 好友A和好友B同时来到银行，首先好友A获取到你的余额为0，太穷了。
2. 好友B此时也获取到你的余额为0，然后给你转账1000，总额度变为0+1000=1000。
3. 好友A也给你转账1000，总额度变为还是为1000，这结果肯定是不对的。

悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。

即使使用了悲观锁，还是存在问题，由于悲观锁使所有的访问者同步进行，大量的访问就会阻塞，占用系统资源，最后的结果不可料想。此时乐观锁的作用就诞生了。

> 数据库中，在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。

拿比较常用的MySql Innodb引擎举例，来说明一下在SQL中如何使用悲观锁。要使用悲观锁，我们必须关闭MySQL数据库的自动提交属性。因为MySQL默认使用autocommit模式（自动提交事务），也就是说，当我们执行一个更新操作后，MySQL会立刻将结果进行提交。

```mysql
sql语句：set autocommit=0
```

以网购扣减库存来说明一下悲观锁的使用：

```mysql
//开启事务
begin；
select quantity from goods where id=1 for update；
update goods set quantity=2 where id =1;
//提交事务
commit;
```

以上，在对id = 1的记录修改前，先通过for update的方式进行加锁，然后再进行修改。如果以上修改库存的代码发生并发，同一时间只有一个线程可以开启事务并获得id=1的锁，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。

上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表锁。

### 乐观锁

乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。**由于乐观锁没有了锁等待，提高了吞吐量，所以乐观锁适合多读少写的场景。** 常见的乐观锁实现方式是：**版本号version**和**CAS**。

采用上面的例子，使用乐观锁加版本号的方式，给数据库的表增加一个字段version版本号，执行的操作如下：

- 你的好友A获取你的余额为0并获取当前的版本号version=0。
- 好友B也同时获取你的余额为0并获取当前的版本号version=0。
- 好好友A转账后的总额为1000，并使版本号version+1=1。更新到数据库中。
- 好友B同时也将金额1000汇进你的账号中，并使版本号version+1=1，提交事务的时候，发现版本号已被修改，提交事务失败，更新不成功。
- 此时好友B需要再次执行转账操作，才能给你转账成功。

> 相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。

使用乐观锁就不需要借助数据库的锁机制了。乐观锁的概念中其实已经阐述了它的具体实现细节。主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是CAS。

CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。