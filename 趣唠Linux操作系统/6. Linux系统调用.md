### Linux系统调用

#### 进程管理

1. 创建进程的系统调用为fork

   在Linux里，要创建一个新的进程，需要一个老的进程调用fork来实现，其中老的进程叫父进程（Parent Process），新的进程叫子进程（Child Process）

   当父进程调用fork创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝的。如果不进行特殊处理，父进程和子进程是按相同代码进行下去的。

   所以我们往往这样处理，对于**fork系统调用**的**返回值**，如果当前进程是**子进程**，就返回**0**，如果当前进程是**父进程**则返回**子进程的进程号**。然后通过if-else语句判断，如果父进程，还可以做原来的事，如果是子进程需要请求另一个系统调用**execve**来执行另一个程序。

2. 父进程调用**waitpid**查看子进程状况

   **父进程**将**子进程的进程号**作为**参数**传给它，父进程就知道子进程运行完了没有

   

#### 内存管理

在操作系统中，**每个进程独有自己的内存**。互相之间不干扰，有独立的进程内存空间。

进程的内存空间来件，放程序代码的这部分，称为**代码段**（Code Segment）

对于进程的内存空间来讲，放进程运行中产生数据的这部分，我们称为**数据段**（Data Segment）。其中局部变量的部分，在当前函数执行的时候起作用，当进入另一个函数时，这个变量就释放了；也有动态分配的，会在很长时间保存，指明才能销毁，这部分称为**堆**（Heap）

在堆里面分配内存的系统调用，**brk**和**mmap**

当分配的内存数量比较小的时候，使用brk，会和原来的堆的数据连在一起。当分配内存数量比较大的时候，使用mmap，重新划分一块区域。



#### 文件管理

文件的关键两点：一是**介质**，一是**格式**

对于文件操作，六个系统调用式最重要。

- 对于已有的文件，使用**open**打开，使用**close**关闭
- 对于没有的文件，使用**create**创建
- 打开文件后，使用**lseek**跳到文件的某个位置
- 可以对文件的内容进行读写，读的系统调用式**read**，写是**write**

Linux**一切皆文件**

- 启动一个程序，程序需是二进制文件
- 加载配置文件，是文本文件
- 日志的标准输出**stdout文件**
- 进程的输出可以做另一个进程的输入，**管道**也是一个文件
- 进程通过网络通信，Socket也是一个文件
- 设备也是一个文件
- 进程运行，查看进程运行情况，/proc下对应的进程号

#### 信号处理

- 在执行一个程序时，键盘输入CTRL+C，这个是中断信号
- 如果非法访问内存
- 硬件故障
- 用户使用kill函数

SIGKILL 终止一个进程的信号

SIGSTOP 中止一个进程的信号

通过sigaction系统调用，注册一个信号处理函数

#### 进程间通信

- 发送消息

  消息队列（Message Queue）

  队列在内存中，我们通过**msgget**创建一个新的队列，**msgnd**将消息发送到队列，消息接受方可以使用**msgrcv**从队列中取消息

- 共享内存

  **shmget**创建一个共享内存块，通过**shmat**将共享内存映射到自己的内存空间

  内存共享必然带来竞争，可以使用排他访问，这就是信号量的机制**Semaphore**

- 信号量

  一个人访问，调用sem_wait设置信号量为1，如果没人访问了，获取到这个信号量，就可以访问了，访问完释放信号量使用**sem_post**

#### 网络间通信

Socket系统调用可以建立一个Socket。Socket也是一个文件，也是一个文件描述符，也可以通过读写函数进行通信

查看内核源码的系统调用 - unistd_64.h

#### 中介与Glibc

开发时，你可以使用系统调用，也可以使用中介Glibc，它会帮你调用系统调用

Glibc下实现的malloc、calloc、free等函数分配释放内存，都利用了内核的sys_brk的系统调用



下图展示系统调用的一个概括

![image-20200515125539282](D:\workIdea\learn\img\image-20200515125539282.png)



命令strace，常用来跟踪进程执行时系统调用和所接受的信号